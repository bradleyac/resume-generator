@using Fluxor
@using Fluxor.Blazor.Web.Components
@using R3
@using RGS.Backend.Shared.ViewModels
@using RGS.Frontend.Store.EditSourceResumeDataFeature
@inherits FluxorComponent

<EditForm EditContext="@EditContext" FormName="EditJob">
  <DataAnnotationsValidator />
  <ValidationSummary />
  <div class="d-flex flex-column gap-4">
    <FormField @bind-Value="@(Model.Title)" class="col-6" />
    <FormField @bind-Value="@(Model.Company)" class="col-6" />
    <FormField @bind-Value="@(Model.Location)" class="col-6" />
    <FormField @bind-Value="@(Model.Start)" class="col-6" />
    <FormField @bind-Value="@(Model.End)" class="col-6" />
    <div class="d-flex flex-column flex-wrap gap-3 ms-3">
      @foreach (var (item, index) in @Model.Bullets.WithIndex())
      {
        <Badge Style="width: min-content" @key="@index" Color="BadgeColor.Success" Position="Position.Relative">@item<Badge style="aspect-ratio: 1 / 1; display: flex; place-items: center" IndicatorType="BadgeIndicatorType.RoundedCircle" Color="BadgeColor.Danger" Position="Position.Absolute" Placement="BadgePlacement.TopLeft" @onclick="@(() => RemoveBulletAt(index))">
            <Icon Name="IconName.XLg" />
          </Badge>
        </Badge>
      }
    </div>
    <div class="d-flex gap-2 place-items-center">
      <label for="@newEntryId" class="collapse">Add Bullet</label>
      <input id="@newEntryId" type="text" class="col-sm-6 col-md-4 col-lg-3" @bind-value="@NewBullet" @bind-value:event="oninput" />
      <Button Type="ButtonType.Button" Color="ButtonColor.Primary" disabled="@(NewBullet is null or "")" @onclick="AddBullet">Add Bullet</Button>
    </div>
  </div>
</EditForm>

@code {
  private EditContext EditContext { get; set; } = null!;
  [Inject] private IDispatcher Dispatcher { get; set; } = null!;
  [Inject] private IStateSelection<EditSourceResumeDataState, Job?> JobSelector { get; set; } = null!;
  [Parameter] public required int JobIndex { get; set; }
  public JobModel Model { get; set; } = null!;
  private string NewBullet { get; set; } = "";
  private string newEntryId = Guid.NewGuid().ToString();
  private CompositeDisposable _subscription = new();
  private bool _disposedValue;

  private async Task AddBullet()
  {
    Dispatcher.Dispatch(new AddBulletAction { Bullet = NewBullet, JobIndex = JobIndex });
    NewBullet = "";
  }

  private async Task RemoveBulletAt(int index)
  {
    Dispatcher.Dispatch(new RemoveBulletAction { BulletIndex = index, JobIndex = JobIndex });
  }

  protected override void OnInitialized()
  {
    base.OnInitialized();

    JobSelector.Select(state => state.ResumeData?.Jobs[JobIndex]);

    Model = new()
    {
      Id = JobSelector.Value?.id!,
      Company = JobSelector.Value?.Company,
      Title = JobSelector.Value?.Title,
      Location = JobSelector.Value?.Location,
      Start = JobSelector.Value?.Start,
      End = JobSelector.Value?.End,
      Bullets = [.. JobSelector.Value?.Bullets ?? []],
    };

    JobSelector.ValueChanges().Subscribe(job =>
    {
      Model?.Company = job?.Company;
      Model?.Title = job?.Title;
      Model?.Location = job?.Location;
      Model?.Start = job?.Start;
      Model?.End = job?.End;
      Model?.Bullets = [.. job?.Bullets ?? []];
      StateHasChanged();
    });

    SubscribeToAction((UpdateResumeDataResultAction action) =>
    {
      if (action.Success)
      {
        EditContext.MarkAsUnmodified();
      }
    });

    EditContext = new EditContext(Model);
    EditContext.Validate();
    Observable.FromEventHandler<FieldChangedEventArgs>(
    a => EditContext.OnFieldChanged += a,
    a => EditContext.OnFieldChanged -= a
    ).Select(args => args.sender as EditContext)
    .WhereNotNull()
    .Where(ec => ec.Validate())
    .Select(ec => (JobModel)ec.Model)
    .Subscribe(model =>
    {
      Dispatcher.Dispatch(new UpdateJobAction(JobIndex, new Job(model.Id, model.Title!, model.Company!, model.Location!, model.Start!, model.End!, [.. model.Bullets])));
    })
    .AddTo(_subscription);
  }

  protected override async ValueTask DisposeAsyncCore(bool disposing)
  {
    await base.DisposeAsyncCore(disposing);

    if (!_disposedValue)
    {
      _subscription.Dispose();
    }

    _disposedValue = true;
  }
}